// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

contract UniversityVoting {
    address public immutable owner;
    address public admin1;
    address public admin2;

    modifier onlyAdmin() {
        require(
            msg.sender == owner || msg.sender == admin1 || msg.sender == admin2,
            "Not an admin"
        );
        _;
    }

    modifier onlyOwner() {
        require(msg.sender == owner, "Only owner");
        _;
    }

    error AlreadyVoted();
    error InvalidNonce();
    error ElectionNotActive();
    error CandidateNotFound();
    error TicketNotFound();
    error InvalidTimes();
    error ElectionExists();
    error ElectionNotEnded();
    error AlreadyFinalized();

    constructor() {
        owner = msg.sender;
    }

    function setAdmin1(address _admin) external onlyOwner {
        admin1 = _admin;
        emit AdminAssigned(1, _admin);
    }

    function setAdmin2(address _admin) external onlyOwner {
        admin2 = _admin;
        emit AdminAssigned(2, _admin);
    }

    function removeAdmin(uint8 adminSlot) external onlyOwner {
        require(adminSlot == 1 || adminSlot == 2, "Invalid slot");
        if (adminSlot == 1) admin1 = address(0);
        if (adminSlot == 2) admin2 = address(0);
        emit AdminRemoved(adminSlot);
    }

    enum ElectionStatus { Pending, Active, Completed }

    struct Election {
        uint64 startTime;
        uint64 endTime;
        ElectionStatus status;
        bool resultsFinalized;
        uint32 totalVotesCast;
    }

    struct Candidate {
        bytes32 studentIdHash;
        uint32 voteCount;
    }

    struct Ticket {
        bytes32 presIdHash;
        bytes32 vpIdHash;
        uint32 voteCount;
    }

    mapping(uint256 => Election) public elections;
    mapping(uint256 => mapping(bytes32 => Candidate)) public electionCandidates;
    mapping(uint256 => mapping(bytes32 => Ticket)) public electionTickets;
    mapping(uint256 => bytes32[]) public candidateHashes;
    mapping(uint256 => bytes32[]) public ticketHashes;

    mapping(uint256 => mapping(address => bool)) public hasVoted;
    mapping(address => mapping(uint256 => uint256)) public voterNonces;

    mapping(uint256 => bytes32) public electionWinnerCandidate;
    mapping(uint256 => bytes32) public electionWinnerTicket;

    mapping(uint256 => bytes32[]) public tiedCandidates;
    mapping(uint256 => bytes32[]) public tiedTickets;

    mapping(bytes32 => string) public studentIdToString;

    event ElectionCreated(uint256 startTime, uint256 endTime);
    event CandidateAdded(uint256 startTime, bytes32 studentIdHash);
    event TicketAdded(uint256 startTime, bytes32 presHash, bytes32 vpHash);
    event VoteCast(uint256 startTime, address voter, uint256 nonce);
    event AdminAssigned(uint8 adminSlot, address admin);
    event AdminRemoved(uint8 adminSlot);
    event ElectionFinalized(uint256 startTime, bytes32 winnerId);
    event TieDetected(uint256 startTime, uint256 maxVotes, uint256 count);

    function createElectionWithCandidates(
        uint256 startTime,
        uint256 endTime,
        bool isTicketBased,
        bytes32[] calldata candidateIds,
        string[] calldata candidateStrings,
        bytes32[][] calldata ticketPairs,
        string[][] calldata ticketStrings
    ) external onlyAdmin {
        if (startTime <= block.timestamp || endTime <= startTime) revert InvalidTimes();
        if (elections[startTime].startTime != 0) revert ElectionExists();
        require(candidateIds.length == candidateStrings.length, "Mismatched candidate arrays");
        require(ticketPairs.length == ticketStrings.length, "Mismatched ticket arrays");

        elections[startTime] = Election({
            startTime: uint64(startTime),
            endTime: uint64(endTime),
            status: ElectionStatus.Pending,
            resultsFinalized: false,
            totalVotesCast: 0
        });

        emit ElectionCreated(startTime, endTime);

        if (isTicketBased) {
            for (uint i = 0; i < ticketPairs.length; i++) {
                bytes32 pres = ticketPairs[i][0];
                bytes32 vp = ticketPairs[i][1];
                require(pres != vp, "President and VP must be different");
                bytes32 hash = keccak256(abi.encodePacked(pres, "_", vp));
                electionTickets[startTime][hash] = Ticket(pres, vp, 0);
                ticketHashes[startTime].push(hash);
                studentIdToString[pres] = ticketStrings[i][0];
                studentIdToString[vp] = ticketStrings[i][1];
                emit TicketAdded(startTime, pres, vp);
            }
        } else {
            for (uint i = 0; i < candidateIds.length; i++) {
                bytes32 id = candidateIds[i];
                electionCandidates[startTime][id] = Candidate(id, 0);
                candidateHashes[startTime].push(id);
                studentIdToString[id] = candidateStrings[i];
                emit CandidateAdded(startTime, id);
            }
        }
    }

    function updateElectionStatus(uint256 startTime) public {
        Election storage election = elections[startTime];
        if (election.status == ElectionStatus.Completed) return;

        if (block.timestamp >= election.startTime && block.timestamp <= election.endTime) {
            election.status = ElectionStatus.Active;
        } else if (block.timestamp > election.endTime) {
            election.status = ElectionStatus.Completed;
        }
    }

    function voteForCandidate(uint256 startTime, bytes32 studentIdHash, uint256 nonce) external {
        updateElectionStatus(startTime);
        Election storage election = elections[startTime];
        if (election.status != ElectionStatus.Active) revert ElectionNotActive();
        if (hasVoted[startTime][msg.sender]) revert AlreadyVoted();
        if (nonce <= voterNonces[msg.sender][startTime]) revert InvalidNonce();

        Candidate storage candidate = electionCandidates[startTime][studentIdHash];
        if (candidate.studentIdHash == bytes32(0)) revert CandidateNotFound();

        candidate.voteCount++;
        election.totalVotesCast++;
        hasVoted[startTime][msg.sender] = true;
        voterNonces[msg.sender][startTime] = nonce;

        emit VoteCast(startTime, msg.sender, nonce);
    }

    function voteForTicket(uint256 startTime, bytes32 presHash, bytes32 vpHash, uint256 nonce) external {
        updateElectionStatus(startTime);
        Election storage election = elections[startTime];
        if (election.status != ElectionStatus.Active) revert ElectionNotActive();
        if (hasVoted[startTime][msg.sender]) revert AlreadyVoted();
        if (nonce <= voterNonces[msg.sender][startTime]) revert InvalidNonce();

        bytes32 hash = keccak256(abi.encodePacked(presHash, "_", vpHash));
        Ticket storage ticket = electionTickets[startTime][hash];
        if (ticket.presIdHash == bytes32(0)) revert TicketNotFound();

        ticket.voteCount++;
        election.totalVotesCast++;
        hasVoted[startTime][msg.sender] = true;
        voterNonces[msg.sender][startTime] = nonce;

        emit VoteCast(startTime, msg.sender, nonce);
    }

    function finalizeResults(uint256 startTime, bool isTicketBased) external onlyAdmin {
        Election storage election = elections[startTime];
        if (block.timestamp <= election.endTime) revert ElectionNotEnded();
        if (election.resultsFinalized) revert AlreadyFinalized();

        bytes32 winnerId;
        uint256 maxVotes = 0;
        bool tie = false;

        if (isTicketBased) {
            bytes32[] storage hashes = ticketHashes[startTime];
            delete tiedTickets[startTime];

            for (uint i = 0; i < hashes.length; i++) {
                Ticket storage ticket = electionTickets[startTime][hashes[i]];
                if (ticket.voteCount > maxVotes) {
                    maxVotes = ticket.voteCount;
                    winnerId = hashes[i];
                    tie = false;
                    delete tiedTickets[startTime];
                    tiedTickets[startTime].push(hashes[i]);
                } else if (ticket.voteCount == maxVotes && maxVotes > 0) {
                    tie = true;
                    tiedTickets[startTime].push(hashes[i]);
                }
            }

            if (tie && tiedTickets[startTime].length > 1) {
                emit TieDetected(startTime, maxVotes, tiedTickets[startTime].length);
                return;
            }

            electionWinnerTicket[startTime] = winnerId;
        } else {
            bytes32[] storage hashes = candidateHashes[startTime];
            delete tiedCandidates[startTime];

            for (uint i = 0; i < hashes.length; i++) {
                Candidate storage candidate = electionCandidates[startTime][hashes[i]];
                if (candidate.voteCount > maxVotes) {
                    maxVotes = candidate.voteCount;
                    winnerId = hashes[i];
                    tie = false;
                    delete tiedCandidates[startTime];
                    tiedCandidates[startTime].push(hashes[i]);
                } else if (candidate.voteCount == maxVotes && maxVotes > 0) {
                    tie = true;
                    tiedCandidates[startTime].push(hashes[i]);
                }
            }

            if (tie && tiedCandidates[startTime].length > 1) {
                emit TieDetected(startTime, maxVotes, tiedCandidates[startTime].length);
                return;
            }

            electionWinnerCandidate[startTime] = winnerId;
        }

        election.resultsFinalized = true;
        emit ElectionFinalized(startTime, winnerId);
    }

    function getWinnerCandidate(uint256 startTime) external view returns (string memory) {
        bytes32 winnerHash = electionWinnerCandidate[startTime];
        return studentIdToString[winnerHash];
    }

    function getWinnerTicket(uint256 startTime) external view returns (string memory, string memory) {
        bytes32 hash = electionWinnerTicket[startTime];
        Ticket memory winner = electionTickets[startTime][hash];
        return (
            studentIdToString[winner.presIdHash],
            studentIdToString[winner.vpIdHash]
        );
    }

    function getTiedCandidates(uint256 startTime) external view returns (string[] memory) {
        bytes32[] memory hashes = tiedCandidates[startTime];
        string[] memory names = new string[](hashes.length);
        for (uint i = 0; i < hashes.length; i++) {
            names[i] = studentIdToString[hashes[i]];
        }
        return names;
    }

    function getTiedTickets(uint256 startTime) external view returns (string[][] memory) {
        bytes32[] memory hashes = tiedTickets[startTime];
        string[][] memory result = new string[][](hashes.length);
        for (uint i = 0; i < hashes.length; i++) {
            Ticket memory t = electionTickets[startTime][hashes[i]];
            result ;
            result[i][0] = studentIdToString[t.presIdHash];
            result[i][1] = studentIdToString[t.vpIdHash];
        }
        return result;
    }

    function getCandidateVotes(uint256 startTime, bytes32 studentIdHash) external view returns (uint256) {
        return electionCandidates[startTime][studentIdHash].voteCount;
    }

    function getTicketVotes(uint256 startTime, bytes32 presHash, bytes32 vpHash) external view returns (uint256) {
        bytes32 hash = keccak256(abi.encodePacked(presHash, "_", vpHash));
        return electionTickets[startTime][hash].voteCount;
    }

    function hasUserVoted(uint256 startTime, address user) external view returns (bool) {
        return hasVoted[startTime][user];
    }

    function getAdmins() external view returns (address, address, address) {
        return (owner, admin1, admin2);
    }
}
