âœ… Using the ABI to Interact with the UniversityVoting Contract
This ABI (Application Binary Interface) defines the full set of functions and events exposed by your deployed smart contract. It's used to connect, call, and listen to blockchain data via libraries like Ethers.js, Viem, or Web3.js.

ðŸ”§ Setup Instructions (with Ethers.js)
Import ABI and configure provider/signer:

ts
Copy
Edit
import { ethers } from "ethers";
import contractABI from "@/lib/abi/universityVotingABI.json"; // Store your ABI as a .json
const contractAddress = "0xYourDeployedContractAddress";

const provider = new ethers.providers.Web3Provider(window.ethereum);
const signer = provider.getSigner();
const contract = new ethers.Contract(contractAddress, contractABI, signer);
ðŸ” Admin Functions
setAdmin1(address)

setAdmin2(address)

ts
Copy
Edit
await contract.setAdmin1("0xAdminAddressHere");
Used to assign admin rights. Must be called by an existing admin (owner, admin1, or admin2).

ðŸ—³ï¸ Election Management
createElection(startTime, endTime)

ts
Copy
Edit
await contract.createElection(startTimestamp, endTimestamp);
Creates a new election, using the UNIX timestamp for both start and end times.

ðŸ‘¨â€ðŸŽ“ Candidate & Ticket Management
Add a senator:

ts
Copy
Edit
await contract.addCandidate(startTime, "202005432");
Add a president + VP ticket:

ts
Copy
Edit
await contract.addTicket(startTime, "202000111", "202000222");
Each candidate or ticket is uniquely identified by the studentId (or concatenated student IDs for tickets).

âœ… Voting (With Nonce)
Vote for a candidate:

ts
Copy
Edit
await contract.voteForCandidate(startTime, "202005432", nonce);
Vote for a ticket:

ts
Copy
Edit
await contract.voteForTicket(startTime, "202000111", "202000222", nonce);
You must pass a nonce (a number higher than the last one used for this election) to protect against replay attacks.

ðŸ“Š Reading Election Data
These are view functions (no gas cost):

getCandidateVotes(startTime, studentId)

ts
Copy
Edit
const votes = await contract.getCandidateVotes(startTime, "202005432");
getTicketVotes(startTime, presidentId, vpId)

ts
Copy
Edit
const votes = await contract.getTicketVotes(startTime, "202000111", "202000222");
getWinnerCandidate(startTime)

getWinnerTicket(startTime)

hasUserVoted(startTime, walletAddress)

getAdmins()

ðŸ• Election Status & Finalization
updateElectionStatus(startTime) Updates the election status automatically based on the block timestamp (from Pending â†’ Active â†’ Completed).

finalizeResults(startTime, isTicketBased) Calculates and stores the winner (based on vote counts). Must be called manually by an admin after the election ends.

ðŸ“¢ Event Listening (Optional)
Listen to key events like:

ts
Copy
Edit
contract.on("VoteCast", (startTime, voter, nonce) => {
  console.log(`VoteCast by ${voter} in election ${startTime}`);
});

contract.on("VoteRejected", (startTime, voter, reason) => {
  console.error(`VoteRejected for ${voter}: ${reason}`);
});
ðŸ’¡ Tip: Best Practices
Always sync your Web2 elections using startTime (this is your unique identifier for both smart contract and DB).

Always keep nonce tracking per user per election.

Ensure your frontend includes timestamp conversion and validation when creating elections.

