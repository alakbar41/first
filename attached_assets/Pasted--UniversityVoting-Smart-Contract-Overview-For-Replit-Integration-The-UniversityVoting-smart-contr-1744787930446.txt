âœ… UniversityVoting Smart Contract Overview (For Replit Integration)
The UniversityVoting smart contract is a blockchain-based voting system designed for university elections, supporting both Senator and President/Vice President types of elections. It provides secure, timestamp-based election management, candidate/ticket voting, and role-based administration.

ğŸ” Admin Access & Roles
Three admins are supported: the contract owner (deployer) and two additional addresses (admin1 and admin2) which can be assigned through the frontend using setAdmin1() and setAdmin2().

All privileged actions (e.g., creating elections, adding candidates) require the onlyAdmin modifier.

ğŸ“… Election Management
Elections are uniquely identified using their start timestamp (startTime) â€” this ensures perfect synchronization between Web2 (your PostgreSQL/Drizzle schema) and Web3 (the smart contract).

The createElection() function initializes a new election with a start and end time. Each election is stored in the elections mapping.

ğŸ‘¨â€ğŸ“ Candidate & Ticket Structure
Senator elections: Candidates are added individually using their student ID via addCandidate().

President/VP elections: Candidates are added as a pair (ticket) using addTicket(), where a unique composite key (presidentId_vpId) is generated and stored in the electionTickets mapping.

ğŸ—³ Voting Logic
Voters can cast their votes with voteForCandidate() or voteForTicket() based on the election type.

A per-election vote tracker (hasVoted) ensures each address can vote only once per election.

Nonces (voterNonces) are used to prevent replay attacks.

Voting is only allowed during the Active phase of an election, which is automatically updated based on block timestamps via updateElectionStatus().

ğŸ¥‡ Result Finalization
After the election ends, finalizeResults() can be called to determine the winner:

For senator elections, the candidate with the most votes is stored in electionWinnerCandidate.

For president/VP elections, the ticket with the most votes is stored in electionWinnerTicket.

Results are stored per election and are viewable through getWinnerCandidate() or getWinnerTicket().

ğŸ“Š Public View Functions
getCandidateVotes(startTime, studentId)

getTicketVotes(startTime, presidentId, vpId)

hasUserVoted(startTime, userAddress)

getAdmins() â€“ to retrieve current admin addresses

ğŸ“¤ Using the ABI to Interact with the Contract
To interact with this contract from your frontend (e.g., React + Wagmi, Ethers.js, or Viem):

Import the ABI JSON file that matches this contract.

Connect your app to the Ethereum provider (like MetaMask or WalletConnect).

Create a contract instance using new ethers.Contract(contractAddress, abi, signerOrProvider).

Call functions like:

await contract.voteForCandidate(startTime, studentId, nonce)

await contract.createElection(startTime, endTime)

await contract.getCandidateVotes(startTime, studentId)

The ABI file allows you to read/write data on-chain using the contractâ€™s exposed functions.

âœ… Summary: Why This Contract Is Strong
âœ… Role-based admin system with flexibility.

âœ… Timestamp-based unique election identifiers (perfect Web2/Web3 match).

âœ… Secure vote casting with replay protection.

âœ… Support for individual and pair-based elections.

âœ… Public functions for seamless frontend integration.

âœ… Gas-efficient and well-structured.